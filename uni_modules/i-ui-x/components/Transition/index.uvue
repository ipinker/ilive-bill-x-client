<template>
	<view ref="transitionRef" :class="customClass" :style="transformStyles" @click="handleClick">
		<slot></slot>
	</view>
</template>

<script lang="ts" setup>
	import { onMounted, onBeforeUnmount, Ref, ref, reactive, nextTick, PropType } from "vue"
	import { StyleValue } from "../../typing"
	import { CLICK_EVENT, CHANGE_EVENT } from "../../common/constants"
	import { transitionProps, TransitionPropsType, ModeType, TimingFunction } from "./transition"
	const props : TransitionPropsType = defineProps(transitionProps);
	const emits = defineEmits([CLICK_EVENT, CHANGE_EVENT]);

	const transitionRef : Ref<Element | null> = ref(null);
	let isShow : Ref<boolean> = ref(false),
		transform : Ref<string> = ref(''),
		opacity : Ref<number> = ref(1),
		duration : Ref<number> = ref(400),
		timingFunction: Ref<TimingFunction> = ref("ease"),
		transformOrigin: Ref<string> = ref("50% 50%"),
		delay: Ref<number> = ref(0),
		timer : Ref<number> = ref(0);

	watch(() => props.show, (newVal : boolean) => {
		if (newVal) {
			nextTick(() => open())
		} else {
			if (isShow.value) close();
		}
	}, { immediate: true });

	// 初始化动画条件
	const transformStyles = computed<string>(() : string => {
		const transitionProperty = props.mode.indexOf("fade") > -1 ? "opacity" : "transform";
		const transitionStyleStr = `transform: ${transform.value
			}; opacity: ${opacity.value
			}; transition-duration${duration.value + 's'
			}; transition-property:${transitionProperty
			}; transition-timing-function: ${timingFunction.value};`;
			console.log(transitionStyleStr)
		return transitionStyleStr;
	})
	// 处理内置组合动画
	function animationType(type : any) : any {
		return {
			fade: type ? 1 : 0,
			'slide-top': `translateY(${type ? '0' : '-100%'})`,
			'slide-right': `translateX(${type ? '0' : '100%'})`,
			'slide-bottom': `translateY(${type ? '0' : '100%'})`,
			'slide-left': `translateX(${type ? '0' : '-100%'})`,
			'zoom-in': `scaleX(${type ? 1 : 0.8}) scaleY(${type ? 1 : 0.8})`,
			'zoom-out': `scaleX(${type ? 1 : 1.2}) scaleY(${type ? 1 : 1.2})`
		}
	}
	// 内置动画类型与实际动画对应字典
	function animationMode() {
		return {
			fade: 'opacity',
			'slide-top': 'translateY',
			'slide-right': 'translateX',
			'slide-bottom': 'translateY',
			'slide-left': 'translateX',
			'zoom-in': 'scale',
			'zoom-out': 'scale'
		}
	}
	// 驼峰转中横线
	function toLine(name : string) {
		return name.replace(/([A-Z])/g, '-$1').toLowerCase()
	}
	// 处理内置组合动画
	function tranfromInit(type : boolean) {
		const cssProps = animationMode();
		let valueType : "string" | "number" = "string",
			aniNum : string = "";
		let buildTranfrom = (type : boolean, modeType : string) => {
			if (modeType === 'fade') {
				aniNum = type ? "0" : "1";
				valueType = "number";
			} else if (modeType === 'zoom-in') {
				aniNum = type ? "0.8" : "1"
				valueType = "number";
			} else if (modeType === 'zoom-out') {
				aniNum = type ? "1.2" : "1"
				valueType = "number";
			} else if (modeType === 'slide-right') {
				aniNum = type ? '100%' : '0'
			} else if (modeType === 'slide-bottom') {
				aniNum = type ? '100%' : '0'
			} else {
				aniNum = type ? '-100%' : '0'
			}
			const aniKey = cssProps[modeType as keyof (typeof cssProps)];

			setElStyle(aniKey, aniNum, valueType);
		}

		let modeList : Array<ModeType> = props.mode.split(",") as Array<ModeType>;
		modeList.forEach((modeType : string) => {
			buildTranfrom(type, modeType)
		})

	}
	// 处理动画开始前的默认样式
	function styleInit(type : boolean) : any {
		let styles : StyleValue = {
			transform: ''
		}
		let buildStyle = (type : any, modeType : any) => {
			if (modeType === 'fade') {
				styles.opacity = animationType(type)[modeType] + '';
				setElStyle("opacity", styles.opacity, "number");
			} else {
				styles.transform = animationType(type)[modeType] + ' ';
				setElStyle("transform", styles.transform);
			}
		}
		
		let modeList : Array<ModeType> = props.mode.split(",") as Array<ModeType>;
		modeList.forEach(modeType => {
			buildStyle(type, modeType)
		})
		return styles
	}
	function open() {
		clearTimeout(timer.value);
		transform.value = "";
		isShow.value = true;
		let styleOption = styleInit(false);
		if (typeof styleOption.opacity !== 'undefined') {
			opacity.value = styleOption.opacity
		}
		transform.value = styleOption.transform
		if(transform.value){
			setElStyle("transform-origin", transformOrigin.value);
		}
		nextTick(() => {
			// TODO 定时器保证动画完全执行，目前有些问题，后面会取消定时器
			timer.value = setTimeout(() => {
				tranfromInit(false)
				handleChange();
			}, 20)
		})
	}
	function close() {
		tranfromInit(true);
		timer.value = setTimeout(() => {
			isShow.value = false
			let style = styleInit(false)
			opacity.value = style.opacity || 1
			transform.value = style.transform
		}, duration.value)
		handleChange();
	}
	/**
	 * 设置元素的样式
	 */
	function setElStyle(key : string, value : string, type ?: "number" | "string") {
		// @ts-ignore
		if (key) transitionRef.value?.style?.setProperty(key, type == "number" ? Number(value) : value);
	}
	/**
	 * 点击组件触发回调
	 */
	function handleClick() {
		emits(CLICK_EVENT, {
			detail: isShow.value
		})
	}
	/**
	 * 元素状态改变触发回调
	 */
	function handleChange() {
		emits(CHANGE_EVENT, {
			detail: isShow.value
		})
	}

	onMounted(() => {
		transformOrigin.value = (props.transformOrigin as unknown as string) || '50% 50%';
		timingFunction.value = (props.timingFunction as unknown as string) || 'ease';
		delay.value = (props.delay as unknown as number) || 0;
		duration.value = (props.duration as unknown as number) / 1000;
		nextTick(() => {
			console.log(duration.value)
			styleInit(false)
		})
	})
	onBeforeUnmount(() => {
		clearTimeout(timer.value);
	})
	defineExpose({
		_ref: transitionRef,
		open,
		close
	})
</script>